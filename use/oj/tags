!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BufferStream	httplib.h	/^    BufferStream() {}$/;"	f	class:httplib::BufferStream
BufferStream	httplib.h	/^class BufferStream : public Stream {$/;"	c	namespace:httplib
CPPHTTPLIB_HTTPLIB_H	httplib.h	9;"	d
CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND	httplib.h	81;"	d
CPPHTTPLIB_KEEPALIVE_TIMEOUT_USECOND	httplib.h	82;"	d
Clean	compile.hpp	/^  static void Clean(const std::string& file_name) {$/;"	f	class:Compiler
Client	httplib.h	/^class Client {$/;"	c	namespace:httplib
Client	httplib.h	/^inline Client::Client($/;"	f	class:httplib::Client
Compile	compile.hpp	/^  static bool Compile(const std::string& file_name) {$/;"	f	class:Compiler
CompileAndRun	compile.hpp	/^  static void CompileAndRun(const Json::Value& req, Json::Value* resp) {$/;"	f	class:Compiler
CompileErrorPath	compile.hpp	/^  static std::string CompileErrorPath(const std::string& file_name) {$/;"	f	class:Compiler
Compiler	compile.hpp	/^class Compiler {$/;"	c
Delete	httplib.h	/^inline Server& Server::Delete(const char* pattern, Handler handler)$/;"	f	class:httplib::Server
Delete	httplib.h	/^inline std::shared_ptr<Response> Client::Delete(const char* path)$/;"	f	class:httplib::Client
Delete	httplib.h	/^inline std::shared_ptr<Response> Client::Delete(const char* path, const Headers& headers)$/;"	f	class:httplib::Client
DescPath	oj_model.hpp	/^  static std::string DescPath(const std::string& question_dir) {$/;"	f	class:OjModel
ERROR	util.hpp	/^  ERROR,$/;"	e	enum:LogLevel
ExePath	compile.hpp	/^  static std::string ExePath(const std::string& file_name) {$/;"	f	class:Compiler
FATAL	util.hpp	/^  FATAL,$/;"	e	enum:LogLevel
FLAGS	Makefile	/^FLAGS=-I ~\/third_part\/include -L ~\/third_part\/lib \\$/;"	m
FileUtil	util.hpp	/^class FileUtil {$/;"	c
FromHex	util.hpp	/^	static unsigned char FromHex(unsigned char x) { $/;"	f	class:UrlUtil
Get	httplib.h	/^inline Server& Server::Get(const char* pattern, Handler handler)$/;"	f	class:httplib::Server
Get	httplib.h	/^inline std::shared_ptr<Response> Client::Get(const char* path, Progress progress)$/;"	f	class:httplib::Client
Get	httplib.h	/^inline std::shared_ptr<Response> Client::Get(const char* path, const Headers& headers, Progress progress)$/;"	f	class:httplib::Client
GetAllQuestions	oj_model.hpp	/^  bool GetAllQuestions(std::vector<Question>* questions) const {$/;"	f	class:OjModel
GetQuestionBrief	oj_model.hpp	/^  bool GetQuestionBrief(const std::string& id, Question* question, std::string* code,$/;"	f	class:OjModel
GetQuestionDetail	oj_model.hpp	/^  bool GetQuestionDetail(const std::string& id, const std::string& user_code,$/;"	f	class:OjModel
HPP_FILE	Makefile	/^HPP_FILE=$(shell ls *.hpp *.h)$/;"	m
Handler	httplib.h	/^    typedef std::function<void (const Request&, Response&)> Handler;$/;"	t	class:httplib::Server
Handlers	httplib.h	/^    typedef std::vector<std::pair<std::regex, Handler>> Handlers;$/;"	t	class:httplib::Server
Head	httplib.h	/^inline std::shared_ptr<Response> Client::Head(const char* path)$/;"	f	class:httplib::Client
Head	httplib.h	/^inline std::shared_ptr<Response> Client::Head(const char* path, const Headers& headers)$/;"	f	class:httplib::Client
HeaderPath	oj_model.hpp	/^  static std::string HeaderPath(const std::string& question_dir) {$/;"	f	class:OjModel
Headers	httplib.h	/^typedef std::multimap<std::string, std::string, detail::ci>  Headers;$/;"	t	namespace:httplib
HttpVersion	httplib.h	/^enum class HttpVersion { v1_0 = 0, v1_1 };$/;"	c	namespace:httplib
INFO	util.hpp	/^  INFO,$/;"	e	enum:LogLevel
INVALID_SOCKET	httplib.h	55;"	d
LOG	util.hpp	67;"	d
Load	oj_model.hpp	/^  bool Load(const std::string& config_path) {$/;"	f	class:OjModel
Log	util.hpp	/^inline std::ostream& Log(LogLevel level, const std::string& file_name,$/;"	f
LogLevel	util.hpp	/^enum LogLevel {$/;"	g
Logger	httplib.h	/^    typedef std::function<void (const Request&, const Response&)> Logger;$/;"	t	class:httplib::Server
Match	httplib.h	/^typedef std::smatch                                            Match;$/;"	t	namespace:httplib
MultipartFile	httplib.h	/^struct MultipartFile {$/;"	s	namespace:httplib
MultipartFiles	httplib.h	/^typedef std::multimap<std::string, MultipartFile> MultipartFiles;$/;"	t	namespace:httplib
NOMINMAX	httplib.h	32;"	d
OjModel	oj_model.hpp	/^  OjModel () {$/;"	f	class:OjModel
OjModel	oj_model.hpp	/^class OjModel {$/;"	c
OjView	oj_view.hpp	/^class OjView {$/;"	c
Options	httplib.h	/^inline Server& Server::Options(const char* pattern, Handler handler)$/;"	f	class:httplib::Server
Options	httplib.h	/^inline std::shared_ptr<Response> Client::Options(const char* path)$/;"	f	class:httplib::Client
Options	httplib.h	/^inline std::shared_ptr<Response> Client::Options(const char* path, const Headers& headers)$/;"	f	class:httplib::Client
Params	httplib.h	/^typedef std::multimap<std::string, std::string>                Params;$/;"	t	namespace:httplib
ParseBody	util.hpp	/^  static void ParseBody(const std::string& body,$/;"	f	class:UrlUtil
Post	httplib.h	/^inline Server& Server::Post(const char* pattern, Handler handler)$/;"	f	class:httplib::Server
Post	httplib.h	/^inline std::shared_ptr<Response> Client::Post($/;"	f	class:httplib::Client
Post	httplib.h	/^inline std::shared_ptr<Response> Client::Post(const char* path, const Headers& headers, const Params& params)$/;"	f	class:httplib::Client
Post	httplib.h	/^inline std::shared_ptr<Response> Client::Post(const char* path, const Params& params)$/;"	f	class:httplib::Client
Progress	httplib.h	/^typedef std::function<bool (uint64_t current, uint64_t total)> Progress;$/;"	t	namespace:httplib
Put	httplib.h	/^inline Server& Server::Put(const char* pattern, Handler handler)$/;"	f	class:httplib::Server
Put	httplib.h	/^inline std::shared_ptr<Response> Client::Put($/;"	f	class:httplib::Client
Question	oj_model.hpp	/^struct Question {$/;"	s
ReadFile	util.hpp	/^  static bool ReadFile(const std::string& file_name, std::string* content) {$/;"	f	class:FileUtil
RenderAllQuestions	oj_view.hpp	/^  static void RenderAllQuestions(const std::vector<Question>& questions,$/;"	f	class:OjView
RenderCompileResult	oj_view.hpp	/^  static void RenderCompileResult(const std::string& question_stdout,$/;"	f	class:OjView
RenderQuestion	oj_view.hpp	/^  static void RenderQuestion(const Question& question,$/;"	f	class:OjView
Request	httplib.h	/^struct Request {$/;"	s	namespace:httplib
Response	httplib.h	/^    Response() : status(-1) {}$/;"	f	struct:httplib::Response
Response	httplib.h	/^struct Response {$/;"	s	namespace:httplib
Run	compile.hpp	/^  static int Run(const std::string& file_name,$/;"	f	class:Compiler
SO_OPENTYPE	httplib.h	563;"	d
SO_SYNCHRONOUS_NONALERT	httplib.h	562;"	d
SSLClient	httplib.h	/^class SSLClient : public Client {$/;"	c	namespace:httplib
SSLClient	httplib.h	/^inline SSLClient::SSLClient(const char* host, int port, time_t timeout_sec)$/;"	f	class:httplib::SSLClient
SSLInit	httplib.h	/^    SSLInit() {$/;"	f	class:httplib::detail::SSLInit
SSLInit	httplib.h	/^class SSLInit {$/;"	c	namespace:httplib::detail
SSLServer	httplib.h	/^class SSLServer : public Server {$/;"	c	namespace:httplib
SSLServer	httplib.h	/^inline SSLServer::SSLServer(const char* cert_path, const char* private_key_path)$/;"	f	class:httplib::SSLServer
SSLSocketStream	httplib.h	/^class SSLSocketStream : public Stream {$/;"	c	namespace:httplib
SSLSocketStream	httplib.h	/^inline SSLSocketStream::SSLSocketStream(socket_t sock, SSL* ssl)$/;"	f	class:httplib::SSLSocketStream
S_ISDIR	httplib.h	29;"	d
S_ISREG	httplib.h	25;"	d
Server	httplib.h	/^class Server {$/;"	c	namespace:httplib
Server	httplib.h	/^inline Server::Server()$/;"	f	class:httplib::Server
SocketStream	httplib.h	/^class SocketStream : public Stream {$/;"	c	namespace:httplib
SocketStream	httplib.h	/^inline SocketStream::SocketStream(socket_t sock): sock_(sock)$/;"	f	class:httplib::SocketStream
Solution	oj_data/1/header.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1578708888.1.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584010816.1.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584010852.2.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584010982.3.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584011090.4.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584011267.5.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584011306.6.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584014328.1.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1584014376.2.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1592368420.1.cpp	/^class Solution {$/;"	c	file:
Solution	tmp_files/tmp_1592371791.1.cpp	/^class Solution {$/;"	c	file:
Split	util.hpp	/^  static void Split(const std::string& input, const std::string& split_char,$/;"	f	class:StringUtil
SrcPath	compile.hpp	/^  static std::string SrcPath(const std::string& file_name) {$/;"	f	class:Compiler
StderrPath	compile.hpp	/^  static std::string StderrPath(const std::string& file_name) {$/;"	f	class:Compiler
StdinPath	compile.hpp	/^  static std::string StdinPath(const std::string& file_name) {$/;"	f	class:Compiler
StdoutPath	compile.hpp	/^  static std::string StdoutPath(const std::string& file_name) {$/;"	f	class:Compiler
Stream	httplib.h	/^class Stream {$/;"	c	namespace:httplib
StringUtil	util.hpp	/^class StringUtil {$/;"	c
TailPath	oj_model.hpp	/^  static std::string TailPath(const std::string& question_dir) {$/;"	f	class:OjModel
Test1	oj_data/1/tail.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1578708888.1.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1584010816.1.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1584010852.2.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1584010982.3.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1584011090.4.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1584011267.5.cpp	/^void Test1() {$/;"	f	class:Solution
Test1	tmp_files/tmp_1584011306.6.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1584014328.1.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1584014376.2.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1592368420.1.cpp	/^void Test1() {$/;"	f
Test1	tmp_files/tmp_1592371791.1.cpp	/^void Test1() {$/;"	f
Test2	oj_data/1/tail.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1578708888.1.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1584010816.1.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1584010852.2.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1584010982.3.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1584011090.4.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1584011267.5.cpp	/^void Test2() {$/;"	f	class:Solution
Test2	tmp_files/tmp_1584011306.6.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1584014328.1.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1584014376.2.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1592368420.1.cpp	/^void Test2() {$/;"	f
Test2	tmp_files/tmp_1592371791.1.cpp	/^void Test2() {$/;"	f
TimeStamp	util.hpp	/^  static int64_t TimeStamp() {$/;"	f	class:TimeUtil
TimeStampMS	util.hpp	/^  static int64_t TimeStampMS() {$/;"	f	class:TimeUtil
TimeUtil	util.hpp	/^class TimeUtil {$/;"	c
ToHex	util.hpp	/^	static unsigned char ToHex(unsigned char x) { $/;"	f	class:UrlUtil
UrlDecode	util.hpp	/^	static std::string UrlDecode(const std::string& str) {$/;"	f	class:UrlUtil
UrlEncode	util.hpp	/^	static std::string UrlEncode(const std::string& str) {$/;"	f	class:UrlUtil
UrlUtil	util.hpp	/^class UrlUtil {$/;"	c
WARNING	util.hpp	/^  WARNING,$/;"	e	enum:LogLevel
WSInit	httplib.h	/^    WSInit() {$/;"	f	class:httplib::detail::WSInit
WSInit	httplib.h	/^class WSInit {$/;"	c	namespace:httplib::detail
WriteFile	util.hpp	/^  static bool WriteFile(const std::string& file_name, const std::string& content) {$/;"	f	class:FileUtil
WriteTmpFile	compile.hpp	/^  static std::string WriteTmpFile(const std::string& code) {$/;"	f	class:Compiler
_CRT_NONSTDC_NO_DEPRECATE	httplib.h	17;"	d
_CRT_SECURE_NO_WARNINGS	httplib.h	13;"	d
append	httplib.h	/^    void append(char c) {$/;"	f	class:httplib::detail::stream_line_reader
base_dir_	httplib.h	/^    std::string base_dir_;$/;"	m	class:httplib::Server
bind_internal	httplib.h	/^inline int Server::bind_internal(const char* host, int port, int socket_flags)$/;"	f	class:httplib::Server
bind_to_any_port	httplib.h	/^inline int Server::bind_to_any_port(const char* host, int socket_flags)$/;"	f	class:httplib::Server
body	httplib.h	/^    std::string    body;$/;"	m	struct:httplib::Request
body	httplib.h	/^    std::string body;$/;"	m	struct:httplib::Response
buffer	httplib.h	/^    std::string buffer;$/;"	m	class:httplib::BufferStream
can_compress	httplib.h	/^inline bool can_compress(const std::string& content_type) {$/;"	f	namespace:httplib::detail
ci	httplib.h	/^struct ci {$/;"	s	namespace:httplib::detail
close_socket	httplib.h	/^inline int close_socket(socket_t sock)$/;"	f	namespace:httplib::detail
compress	httplib.h	/^inline void compress(std::string& content)$/;"	f	namespace:httplib::detail
content_type	httplib.h	/^    std::string content_type;$/;"	m	struct:httplib::MultipartFile
create_client_socket	httplib.h	/^inline socket_t Client::create_client_socket() const$/;"	f	class:httplib::Client
create_server_socket	httplib.h	/^inline socket_t Server::create_server_socket(const char* host, int port, int socket_flags) const$/;"	f	class:httplib::Server
create_socket	httplib.h	/^socket_t create_socket(const char* host, int port, Fn fn, int socket_flags = 0)$/;"	f	namespace:httplib::detail
ctx_	httplib.h	/^    SSL_CTX* ctx_;$/;"	m	class:httplib::SSLClient
ctx_	httplib.h	/^    SSL_CTX* ctx_;$/;"	m	class:httplib::SSLServer
ctx_mutex_	httplib.h	/^    std::mutex ctx_mutex_;$/;"	m	class:httplib::SSLClient
ctx_mutex_	httplib.h	/^    std::mutex ctx_mutex_;$/;"	m	class:httplib::SSLServer
decode_url	httplib.h	/^inline std::string decode_url(const std::string& s)$/;"	f	namespace:httplib::detail
decompress	httplib.h	/^inline void decompress(std::string& content)$/;"	f	namespace:httplib::detail
delete_handlers_	httplib.h	/^    Handlers    delete_handlers_;$/;"	m	class:httplib::Server
detail	httplib.h	/^namespace detail {$/;"	n	namespace:httplib
dir	oj_model.hpp	/^  std::string dir;      \/\/ 题目对应的目录$/;"	m	struct:Question
dispatch_request	httplib.h	/^inline bool Server::dispatch_request(Request& req, Response& res, Handlers& handlers)$/;"	f	class:httplib::Server
encode_url	httplib.h	/^inline std::string encode_url(const std::string& s)$/;"	f	namespace:httplib::detail
error_handler_	httplib.h	/^    Handler     error_handler_;$/;"	m	class:httplib::Server
file_extension	httplib.h	/^inline std::string file_extension(const std::string& path)$/;"	f	namespace:httplib::detail
filename	httplib.h	/^    std::string filename;$/;"	m	struct:httplib::MultipartFile
files	httplib.h	/^    MultipartFiles files;$/;"	m	struct:httplib::Request
find_content_type	httplib.h	/^inline const char* find_content_type(const std::string& path)$/;"	f	namespace:httplib::detail
fixed_buffer_	httplib.h	/^    char* fixed_buffer_;$/;"	m	class:httplib::detail::stream_line_reader
fixed_buffer_size_	httplib.h	/^    const size_t fixed_buffer_size_;$/;"	m	class:httplib::detail::stream_line_reader
fixed_buffer_used_size_	httplib.h	/^    size_t fixed_buffer_used_size_;$/;"	m	class:httplib::detail::stream_line_reader
from_hex_to_i	httplib.h	/^inline bool from_hex_to_i(const std::string& s, size_t i, size_t cnt, int& val)$/;"	f	namespace:httplib::detail
from_i_to_hex	httplib.h	/^inline std::string from_i_to_hex(uint64_t n)$/;"	f	namespace:httplib::detail
get_buffer	httplib.h	/^inline const std::string& BufferStream::get_buffer() const {$/;"	f	class:httplib::BufferStream
get_file_value	httplib.h	/^inline MultipartFile Request::get_file_value(const char* key) const$/;"	f	class:httplib::Request
get_handlers_	httplib.h	/^    Handlers    get_handlers_;$/;"	m	class:httplib::Server
get_header_value	httplib.h	/^inline const char* get_header_value($/;"	f	namespace:httplib::detail
get_header_value	httplib.h	/^inline std::string Request::get_header_value(const char* key) const$/;"	f	class:httplib::Request
get_header_value	httplib.h	/^inline std::string Response::get_header_value(const char* key) const$/;"	f	class:httplib::Response
get_header_value_int	httplib.h	/^inline int get_header_value_int(const Headers& headers, const char* key, int def = 0)$/;"	f	namespace:httplib::detail
get_param_value	httplib.h	/^inline std::string Request::get_param_value(const char* key) const$/;"	f	class:httplib::Request
get_remote_addr	httplib.h	/^inline std::string BufferStream::get_remote_addr() const {$/;"	f	class:httplib::BufferStream
get_remote_addr	httplib.h	/^inline std::string SSLSocketStream::get_remote_addr() const {$/;"	f	class:httplib::SSLSocketStream
get_remote_addr	httplib.h	/^inline std::string SocketStream::get_remote_addr() const {$/;"	f	class:httplib::SocketStream
get_remote_addr	httplib.h	/^inline std::string get_remote_addr(socket_t sock) {$/;"	f	namespace:httplib::detail
getline	httplib.h	/^    bool getline() {$/;"	f	class:httplib::detail::stream_line_reader
glowable_buffer_	httplib.h	/^    std::string glowable_buffer_;$/;"	m	class:httplib::detail::stream_line_reader
handle_file_request	httplib.h	/^inline bool Server::handle_file_request(Request& req, Response& res)$/;"	f	class:httplib::Server
has_file	httplib.h	/^inline bool Request::has_file(const char* key) const$/;"	f	class:httplib::Request
has_header	httplib.h	/^inline bool Request::has_header(const char* key) const$/;"	f	class:httplib::Request
has_header	httplib.h	/^inline bool Response::has_header(const char* key) const$/;"	f	class:httplib::Response
has_header	httplib.h	/^inline bool has_header(const Headers& headers, const char* key)$/;"	f	namespace:httplib::detail
has_param	httplib.h	/^inline bool Request::has_param(const char* key) const$/;"	f	class:httplib::Request
headers	httplib.h	/^    Headers        headers;$/;"	m	struct:httplib::Request
headers	httplib.h	/^    Headers     headers;$/;"	m	struct:httplib::Response
host_	httplib.h	/^    const std::string host_;$/;"	m	class:httplib::Client
host_and_port_	httplib.h	/^    const std::string host_and_port_;$/;"	m	class:httplib::Client
httplib	httplib.h	/^namespace httplib$/;"	n
id	oj_model.hpp	/^  std::string id;       \/\/ 题目的 id$/;"	m	struct:Question
isPalindrome	oj_data/1/header.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1578708888.1.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584010816.1.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584010852.2.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584010982.3.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584011090.4.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584011267.5.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584011306.6.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584014328.1.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1584014376.2.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1592368420.1.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
isPalindrome	tmp_files/tmp_1592371791.1.cpp	/^    bool isPalindrome(int x) {$/;"	f	class:Solution
is_connection_error	httplib.h	/^inline bool is_connection_error()$/;"	f	namespace:httplib::detail
is_dir	httplib.h	/^inline bool is_dir(const std::string& path)$/;"	f	namespace:httplib::detail
is_file	httplib.h	/^inline bool is_file(const std::string& path)$/;"	f	namespace:httplib::detail
is_hex	httplib.h	/^inline bool is_hex(char c, int& v)$/;"	f	namespace:httplib::detail
is_running	httplib.h	/^inline bool Server::is_running() const$/;"	f	class:httplib::Server
is_running_	httplib.h	/^    bool        is_running_;$/;"	m	class:httplib::Server
is_valid	httplib.h	/^inline bool Client::is_valid() const$/;"	f	class:httplib::Client
is_valid	httplib.h	/^inline bool SSLClient::is_valid() const$/;"	f	class:httplib::SSLClient
is_valid	httplib.h	/^inline bool SSLServer::is_valid() const$/;"	f	class:httplib::SSLServer
is_valid	httplib.h	/^inline bool Server::is_valid() const$/;"	f	class:httplib::Server
is_valid_path	httplib.h	/^inline bool is_valid_path(const std::string& path) {$/;"	f	namespace:httplib::detail
keep_alive_max_count_	httplib.h	/^    size_t keep_alive_max_count_;$/;"	m	class:httplib::Server
length	httplib.h	/^    size_t length = 0;$/;"	m	struct:httplib::MultipartFile
listen	httplib.h	/^inline bool Server::listen(const char* host, int port, int socket_flags)$/;"	f	class:httplib::Server
listen_after_bind	httplib.h	/^inline bool Server::listen_after_bind() {$/;"	f	class:httplib::Server
listen_internal	httplib.h	/^inline bool Server::listen_internal()$/;"	f	class:httplib::Server
logger_	httplib.h	/^    Logger      logger_;$/;"	m	class:httplib::Server
main	compile_server.cc	/^int main() {$/;"	f
main	oj_data/1/tail.cpp	/^int main() {$/;"	f
main	oj_server.cc	/^int main() {$/;"	f
main	tmp_files/tmp_1578708888.1.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1584010816.1.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1584010852.2.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1584010982.3.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1584011090.4.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1584011267.5.cpp	/^int main() {$/;"	f	class:Solution
main	tmp_files/tmp_1584011306.6.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1584014328.1.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1584014376.2.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1592368420.1.cpp	/^int main() {$/;"	f
main	tmp_files/tmp_1592371791.1.cpp	/^int main() {$/;"	f
make_range_header	httplib.h	/^inline std::pair<std::string, std::string> make_range_header(uint64_t value, Args... args)$/;"	f	namespace:httplib
make_range_header_core	httplib.h	/^inline void make_range_header_core(std::string& field, uint64_t value)$/;"	f	namespace:httplib::detail
make_range_header_core	httplib.h	/^inline void make_range_header_core(std::string& field, uint64_t value1, uint64_t value2, Args... args)$/;"	f	namespace:httplib::detail
make_range_header_core	httplib.h	/^inline void make_range_header_core(std::string&) {}$/;"	f	namespace:httplib::detail
matches	httplib.h	/^    Match          matches;$/;"	m	struct:httplib::Request
method	httplib.h	/^    std::string    method;$/;"	m	struct:httplib::Request
model_	oj_model.hpp	/^  std::unordered_map<std::string, Question> model_;$/;"	m	class:OjModel
offset	httplib.h	/^    size_t offset = 0;$/;"	m	struct:httplib::MultipartFile
operator ()	httplib.h	/^    bool operator() (const std::string & s1, const std::string & s2) const {$/;"	f	struct:httplib::detail::ci
options_handlers_	httplib.h	/^    Handlers    options_handlers_;$/;"	m	class:httplib::Server
params	httplib.h	/^    Params         params;$/;"	m	struct:httplib::Request
parse_multipart_boundary	httplib.h	/^inline bool parse_multipart_boundary(const std::string& content_type, std::string& boundary)$/;"	f	namespace:httplib::detail
parse_multipart_formdata	httplib.h	/^inline bool parse_multipart_formdata($/;"	f	namespace:httplib::detail
parse_query_text	httplib.h	/^inline void parse_query_text(const std::string& s, Params& params)$/;"	f	namespace:httplib::detail
parse_request_line	httplib.h	/^inline bool Server::parse_request_line(const char* s, Request& req)$/;"	f	class:httplib::Server
path	httplib.h	/^    std::string    path;$/;"	m	struct:httplib::Request
port_	httplib.h	/^    const int         port_;$/;"	m	class:httplib::Client
post_handlers_	httplib.h	/^    Handlers    post_handlers_;$/;"	m	class:httplib::Server
process_request	httplib.h	/^inline bool Client::process_request(Stream& strm, Request& req, Response& res, bool& connection_close)$/;"	f	class:httplib::Client
process_request	httplib.h	/^inline bool Server::process_request(Stream& strm, bool last_connection, bool& connection_close)$/;"	f	class:httplib::Server
progress	httplib.h	/^    Progress       progress;$/;"	m	struct:httplib::Request
ptr	httplib.h	/^    const char* ptr() const {$/;"	f	class:httplib::detail::stream_line_reader
put_handlers_	httplib.h	/^    Handlers    put_handlers_;$/;"	m	class:httplib::Server
read	httplib.h	/^inline int BufferStream::read(char* ptr, size_t size)$/;"	f	class:httplib::BufferStream
read	httplib.h	/^inline int SSLSocketStream::read(char* ptr, size_t size)$/;"	f	class:httplib::SSLSocketStream
read	httplib.h	/^inline int SocketStream::read(char* ptr, size_t size)$/;"	f	class:httplib::SocketStream
read_and_close_socket	httplib.h	/^inline bool Client::read_and_close_socket(socket_t sock, Request& req, Response& res)$/;"	f	class:httplib::Client
read_and_close_socket	httplib.h	/^inline bool SSLClient::read_and_close_socket(socket_t sock, Request& req, Response& res)$/;"	f	class:httplib::SSLClient
read_and_close_socket	httplib.h	/^inline bool SSLServer::read_and_close_socket(socket_t sock)$/;"	f	class:httplib::SSLServer
read_and_close_socket	httplib.h	/^inline bool Server::read_and_close_socket(socket_t sock)$/;"	f	class:httplib::Server
read_and_close_socket	httplib.h	/^inline bool read_and_close_socket(socket_t sock, size_t keep_alive_max_count, T callback)$/;"	f	namespace:httplib::detail
read_and_close_socket_ssl	httplib.h	/^inline bool read_and_close_socket_ssl($/;"	f	namespace:httplib::detail
read_content	httplib.h	/^bool read_content(Stream& strm, T& x, Progress progress = Progress())$/;"	f	namespace:httplib::detail
read_content_chunked	httplib.h	/^inline bool read_content_chunked(Stream& strm, std::string& out)$/;"	f	namespace:httplib::detail
read_content_with_length	httplib.h	/^inline bool read_content_with_length(Stream& strm, std::string& out, size_t len, Progress progress)$/;"	f	namespace:httplib::detail
read_content_without_length	httplib.h	/^inline bool read_content_without_length(Stream& strm, std::string& out)$/;"	f	namespace:httplib::detail
read_file	httplib.h	/^inline void read_file(const std::string& path, std::string& out)$/;"	f	namespace:httplib::detail
read_headers	httplib.h	/^inline bool read_headers(Stream& strm, Headers& headers)$/;"	f	namespace:httplib::detail
read_response_line	httplib.h	/^inline bool Client::read_response_line(Stream& strm, Response& res)$/;"	f	class:httplib::Client
routing	httplib.h	/^inline bool Server::routing(Request& req, Response& res)$/;"	f	class:httplib::Server
running_threads_	httplib.h	/^    int         running_threads_;$/;"	m	class:httplib::Server
running_threads_mutex_	httplib.h	/^    std::mutex  running_threads_mutex_;$/;"	m	class:httplib::Server
select_read	httplib.h	/^inline int select_read(socket_t sock, time_t sec, time_t usec)$/;"	f	namespace:httplib::detail
send	httplib.h	/^inline bool Client::send(Request& req, Response& res)$/;"	f	class:httplib::Client
set_base_dir	httplib.h	/^inline bool Server::set_base_dir(const char* path)$/;"	f	class:httplib::Server
set_content	httplib.h	/^inline void Response::set_content(const char* s, size_t n, const char* content_type)$/;"	f	class:httplib::Response
set_content	httplib.h	/^inline void Response::set_content(const std::string& s, const char* content_type)$/;"	f	class:httplib::Response
set_error_handler	httplib.h	/^inline void Server::set_error_handler(Handler handler)$/;"	f	class:httplib::Server
set_header	httplib.h	/^inline void Request::set_header(const char* key, const char* val)$/;"	f	class:httplib::Request
set_header	httplib.h	/^inline void Response::set_header(const char* key, const char* val)$/;"	f	class:httplib::Response
set_keep_alive_max_count	httplib.h	/^inline void Server::set_keep_alive_max_count(size_t count)$/;"	f	class:httplib::Server
set_logger	httplib.h	/^inline void Server::set_logger(Logger logger)$/;"	f	class:httplib::Server
set_nonblocking	httplib.h	/^inline void set_nonblocking(socket_t sock, bool nonblocking)$/;"	f	namespace:httplib::detail
set_redirect	httplib.h	/^inline void Response::set_redirect(const char* url)$/;"	f	class:httplib::Response
shutdown_socket	httplib.h	/^inline int shutdown_socket(socket_t sock)$/;"	f	namespace:httplib::detail
snprintf	httplib.h	21;"	d
sock_	httplib.h	/^    socket_t sock_;$/;"	m	class:httplib::SSLSocketStream
sock_	httplib.h	/^    socket_t sock_;$/;"	m	class:httplib::SocketStream
socket_t	httplib.h	/^typedef SOCKET socket_t;$/;"	t
socket_t	httplib.h	/^typedef int socket_t;$/;"	t
split	httplib.h	/^void split(const char* b, const char* e, char d, Fn fn)$/;"	f	namespace:httplib::detail
ssl_	httplib.h	/^    SSL* ssl_;$/;"	m	class:httplib::SSLSocketStream
sslinit_	httplib.h	/^static SSLInit sslinit_;$/;"	m	namespace:httplib::detail
star	oj_model.hpp	/^  std::string star;     \/\/ 题目难度$/;"	m	struct:Question
status	httplib.h	/^    int         status;$/;"	m	struct:httplib::Response
status_message	httplib.h	/^inline const char* status_message(int status)$/;"	f	namespace:httplib::detail
stop	httplib.h	/^inline void Server::stop()$/;"	f	class:httplib::Server
strcasecmp	httplib.h	39;"	d
stream_line_reader	httplib.h	/^    stream_line_reader(Stream& strm, char* fixed_buffer, size_t fixed_buffer_size)$/;"	f	class:httplib::detail::stream_line_reader
stream_line_reader	httplib.h	/^class stream_line_reader {$/;"	c	namespace:httplib::detail
streamcb	httplib.h	/^    std::function<std::string (uint64_t offset)> streamcb;$/;"	m	struct:httplib::Response
strm_	httplib.h	/^    Stream& strm_;$/;"	m	class:httplib::detail::stream_line_reader
svr_sock_	httplib.h	/^    socket_t    svr_sock_;$/;"	m	class:httplib::Server
target	httplib.h	/^    std::string    target;$/;"	m	struct:httplib::Request
timeout_sec_	httplib.h	/^    time_t            timeout_sec_;$/;"	m	class:httplib::Client
title	oj_model.hpp	/^  std::string title;    \/\/ 题目的标题$/;"	m	struct:Question
to_lower	httplib.h	/^inline std::string to_lower(const char* beg, const char* end)$/;"	f	namespace:httplib::detail
to_utf8	httplib.h	/^inline size_t to_utf8(int code, char* buff)$/;"	f	namespace:httplib::detail
v1_0	httplib.h	/^enum class HttpVersion { v1_0 = 0, v1_1 };$/;"	m	class:httplib::HttpVersion
version	httplib.h	/^    std::string    version;$/;"	m	struct:httplib::Request
version	httplib.h	/^    std::string version;$/;"	m	struct:httplib::Response
wait_until_socket_is_ready	httplib.h	/^inline bool wait_until_socket_is_ready(socket_t sock, time_t sec, time_t usec)$/;"	f	namespace:httplib::detail
write	httplib.h	/^inline int BufferStream::write(const char* ptr)$/;"	f	class:httplib::BufferStream
write	httplib.h	/^inline int BufferStream::write(const char* ptr, size_t size)$/;"	f	class:httplib::BufferStream
write	httplib.h	/^inline int SSLSocketStream::write(const char* ptr)$/;"	f	class:httplib::SSLSocketStream
write	httplib.h	/^inline int SSLSocketStream::write(const char* ptr, size_t size)$/;"	f	class:httplib::SSLSocketStream
write	httplib.h	/^inline int SocketStream::write(const char* ptr)$/;"	f	class:httplib::SocketStream
write	httplib.h	/^inline int SocketStream::write(const char* ptr, size_t size)$/;"	f	class:httplib::SocketStream
write_format	httplib.h	/^inline void Stream::write_format(const char* fmt, const Args& ...args)$/;"	f	class:httplib::Stream
write_headers	httplib.h	/^inline void write_headers(Stream& strm, const T& info)$/;"	f	namespace:httplib::detail
write_request	httplib.h	/^inline void Client::write_request(Stream& strm, Request& req)$/;"	f	class:httplib::Client
write_response	httplib.h	/^inline void Server::write_response(Stream& strm, bool last_connection, const Request& req, Response& res)$/;"	f	class:httplib::Server
wsinit_	httplib.h	/^static WSInit wsinit_;$/;"	m	namespace:httplib::detail
~BufferStream	httplib.h	/^    virtual ~BufferStream() {}$/;"	f	class:httplib::BufferStream
~Client	httplib.h	/^inline Client::~Client()$/;"	f	class:httplib::Client
~SSLClient	httplib.h	/^inline SSLClient::~SSLClient()$/;"	f	class:httplib::SSLClient
~SSLServer	httplib.h	/^inline SSLServer::~SSLServer()$/;"	f	class:httplib::SSLServer
~SSLSocketStream	httplib.h	/^inline SSLSocketStream::~SSLSocketStream()$/;"	f	class:httplib::SSLSocketStream
~Server	httplib.h	/^inline Server::~Server()$/;"	f	class:httplib::Server
~SocketStream	httplib.h	/^inline SocketStream::~SocketStream()$/;"	f	class:httplib::SocketStream
~Stream	httplib.h	/^    virtual ~Stream() {}$/;"	f	class:httplib::Stream
~WSInit	httplib.h	/^    ~WSInit() {$/;"	f	class:httplib::detail::WSInit
